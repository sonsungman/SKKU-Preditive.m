[
  {
    "path": "posts3/2021-09-28 Product Cycle/",
    "title": "Product Cycle",
    "description": "상품 모델링",
    "author": [
      {
        "name": "sonsungman",
        "url": "https://sonsungman.github.io/SKKU-Preditive.m/"
      }
    ],
    "date": "2021-09-28",
    "categories": [],
    "contents": "\r\n상품 모델링\r\n학부 마지막 학기와 대학원 1학기 때에 상품관련하여 Pricing, Reserving, Profit test 까지 엑셀을 활용하여 진행해 보았다. 실무적인 엑셀파일을 얻게된 것이 처음인데 교수님께서 관련 엑셀 파일을 매주 조금씩 업데이트 해주신 것을 각자 받아 학습해오는 식으로 강의가 진행되었던 것으로 기억난다. 대학원 수업에서는 이 엑셀 파일과 함께 삼성, AIA, Met 라이프의 재무제표를 뜯어서 보는 식으로 강의가 진행되었다.\r\n\r\n\r\n\r\nFigure 1: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 2: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 3: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 4: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 5: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 6: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 7: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 8: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 9: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 10: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 11: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 12: 상품 엑셀 파일\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-12-19T20:11:13+09:00",
    "input_file": {}
  },
  {
    "path": "posts3/2021-09-28 Prophet/",
    "title": "Prophet",
    "description": "프로펫에 대하여",
    "author": [
      {
        "name": "sonsungman",
        "url": "https://sonsungman.github.io/SKKU-Preditive.m/"
      }
    ],
    "date": "2021-09-28",
    "categories": [],
    "contents": "\r\n대학원 1학기 때에 (2020) 내 학부 대학원에서 Prophet 관련 1학기 수업을 청강하였다. ABL 현직자께서 오셔서 강의를 하셨는데 프로펫 인터페이스에 익숙해질 수 있었던 좋은 경험이었다. 간단한 정기보험 모델링을 실시 하였다. 저작권상 실무관련 ppt의 내용은 올리수 없을 듯 하다. 마지막의 엑셀 자료는 프로펫으로 모델링한 상품의 현금흐름을 엑셀로 가지고 온 것이다.\r\n\r\n\r\n\r\nFigure 1: 프로펫 수업 관련 파일\r\n\r\n\r\n\r\n\r\nFigure 2: 프로펫 수업 관련 파일\r\n\r\n\r\n\r\n\r\nFigure 3: 프로펫 수업 관련 파일\r\n\r\n\r\n\r\n\r\nFigure 4: 프로펫 수업 관련 파일\r\n\r\n\r\n\r\n\r\nFigure 5: 프로펫 수업 관련 파일\r\n\r\n\r\n\r\n\r\nFigure 6: 프로펫 수업 관련 파일\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-12-19T20:11:13+09:00",
    "input_file": {}
  },
  {
    "path": "posts3/2021-06-02 Bootstrapping/",
    "title": "Bootstrapping",
    "description": "지급준비금의 예측분포 산출을 위한 부트스트랩핑 기법",
    "author": [
      {
        "name": "sonsungman",
        "url": "https://sonsungman.github.io/SKKU-Preditive.m/"
      }
    ],
    "date": "2021-06-02",
    "categories": [],
    "contents": "\r\n내 석사학위논문 주제인 지급준비금의 예측분포를 통한 위험조정금액 산출과 관련하여 MCMC 기법을 통한 산출은 조재훈 교수님의 2016년 논문을 중심으로 발표하였다. 또 다른 기법인 부트스트랩 기법과 관련하여서는 내가 석사학위논문 작성을 위해 엑셀 VBA를 활용하여 파일을 만들고 해당 파일을 발표할 동료 대학원생분들께 넘겨주었다. 해당 수업의 교수님께서 동료 대학원생들에게 해당 자료를 넘기라는 말씀을 하셔서 부득이하게 넘겨 주었던 기억이 난다. 나의 석사학위논문 작성을 위해 제작한 VBA자료이기 때문에 큰 부담은 없었지만 vba제작을 통해 여러측면에서 공부를 해볼 수 있다는 면에서 동료 대학원생들의 기회가 박탈된 것 아닌지 생각이 든다. 어쨋건 지급준비금의 예측분포 산출과 이를 활용한 위험조정금액 산출이라는 주제의 발표가 잘 마무리되었던 것으로 기억난다.\r\n\r\n\r\n\r\nFigure 1: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 2: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 3: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 4: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 5: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 6: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 7: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 8: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\nFigure 9: 부트스트랩핑 엑셀 파일\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-12-19T20:11:13+09:00",
    "input_file": {}
  },
  {
    "path": "posts3/2021-05-29 BDA Project with RStan/",
    "title": "BDA Project with RStan_2",
    "description": "Using Stan",
    "author": [
      {
        "name": "sonsungman",
        "url": "https://sonsungman.github.io/SKKU-Preditive.m/"
      }
    ],
    "date": "2021-05-29",
    "categories": [],
    "contents": "\r\n\r\nShow code\r\nlibrary(tidymodels)\r\nlibrary(tidyverse)\r\nlibrary(magrittr)\r\nlibrary(skimr)\r\nlibrary(knitr)\r\nlibrary(bayesplot)\r\ntheme_set(theme_bw())\r\n\r\n\r\n\r\nMCMC Example\r\n간단한 포아송 모델을 Stan 코드로 작성해보자.\r\n\\(\\lambda \\sim {\\sf Gamma}(1,1)\\)\r\n\\(y_{n} \\sim {\\sf poisson}(\\lambda)\\)\r\n관측치 \\(y_{1}, y_{2}, ..., y_{N}\\) 이 있을때에\r\n\r\nShow code\r\n    poisson_model<-\r\n'  data{\r\n    int<lower = 0> N ;\r\n    int<lower = 0> y[N] ; \r\n  }\r\n  parameters {\r\n    real<lower = 0> lambda ; \r\n  }\r\n  model{\r\n    lambda ~ gamma(1,1) ; \r\n    y ~ poisson(lambda) ; \r\n  }\r\n'  \r\n\r\n\r\n\r\n\r\nShow code\r\n  stanmodel_poisson <- stan(model_code = poisson_model)\r\n\r\n\r\nError in mod$fit_ptr() : \r\n  Exception: variable does not exist; processing stage=data initialization; variable name=N; base type=int  (in 'model4fdc5a185c4c_c6ef9f56b7161f61e60782119367466d' at line 2)\r\nShow code\r\n  y <-c(5,4,0,0,10,0,0,1,2,3,4)\r\n  N = length(y)\r\n  \r\ndata1 <-list(N=N,y=y)\r\n\r\nfit <-stan(model_code=poisson_model , data=data1 , iter =10000, chains=4, warmup = 2000, init = \"random\" )\r\n\r\n\r\n\r\nSAMPLING FOR MODEL 'c6ef9f56b7161f61e60782119367466d' NOW (CHAIN 1).\r\nChain 1: \r\nChain 1: Gradient evaluation took 0 seconds\r\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\r\nChain 1: Adjust your expectations accordingly!\r\nChain 1: \r\nChain 1: \r\nChain 1: Iteration:    1 / 10000 [  0%]  (Warmup)\r\nChain 1: Iteration: 1000 / 10000 [ 10%]  (Warmup)\r\nChain 1: Iteration: 2000 / 10000 [ 20%]  (Warmup)\r\nChain 1: Iteration: 2001 / 10000 [ 20%]  (Sampling)\r\nChain 1: Iteration: 3000 / 10000 [ 30%]  (Sampling)\r\nChain 1: Iteration: 4000 / 10000 [ 40%]  (Sampling)\r\nChain 1: Iteration: 5000 / 10000 [ 50%]  (Sampling)\r\nChain 1: Iteration: 6000 / 10000 [ 60%]  (Sampling)\r\nChain 1: Iteration: 7000 / 10000 [ 70%]  (Sampling)\r\nChain 1: Iteration: 8000 / 10000 [ 80%]  (Sampling)\r\nChain 1: Iteration: 9000 / 10000 [ 90%]  (Sampling)\r\nChain 1: Iteration: 10000 / 10000 [100%]  (Sampling)\r\nChain 1: \r\nChain 1:  Elapsed Time: 0.027 seconds (Warm-up)\r\nChain 1:                0.107 seconds (Sampling)\r\nChain 1:                0.134 seconds (Total)\r\nChain 1: \r\n\r\nSAMPLING FOR MODEL 'c6ef9f56b7161f61e60782119367466d' NOW (CHAIN 2).\r\nChain 2: \r\nChain 2: Gradient evaluation took 0 seconds\r\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\r\nChain 2: Adjust your expectations accordingly!\r\nChain 2: \r\nChain 2: \r\nChain 2: Iteration:    1 / 10000 [  0%]  (Warmup)\r\nChain 2: Iteration: 1000 / 10000 [ 10%]  (Warmup)\r\nChain 2: Iteration: 2000 / 10000 [ 20%]  (Warmup)\r\nChain 2: Iteration: 2001 / 10000 [ 20%]  (Sampling)\r\nChain 2: Iteration: 3000 / 10000 [ 30%]  (Sampling)\r\nChain 2: Iteration: 4000 / 10000 [ 40%]  (Sampling)\r\nChain 2: Iteration: 5000 / 10000 [ 50%]  (Sampling)\r\nChain 2: Iteration: 6000 / 10000 [ 60%]  (Sampling)\r\nChain 2: Iteration: 7000 / 10000 [ 70%]  (Sampling)\r\nChain 2: Iteration: 8000 / 10000 [ 80%]  (Sampling)\r\nChain 2: Iteration: 9000 / 10000 [ 90%]  (Sampling)\r\nChain 2: Iteration: 10000 / 10000 [100%]  (Sampling)\r\nChain 2: \r\nChain 2:  Elapsed Time: 0.022 seconds (Warm-up)\r\nChain 2:                0.111 seconds (Sampling)\r\nChain 2:                0.133 seconds (Total)\r\nChain 2: \r\n\r\nSAMPLING FOR MODEL 'c6ef9f56b7161f61e60782119367466d' NOW (CHAIN 3).\r\nChain 3: \r\nChain 3: Gradient evaluation took 0 seconds\r\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\r\nChain 3: Adjust your expectations accordingly!\r\nChain 3: \r\nChain 3: \r\nChain 3: Iteration:    1 / 10000 [  0%]  (Warmup)\r\nChain 3: Iteration: 1000 / 10000 [ 10%]  (Warmup)\r\nChain 3: Iteration: 2000 / 10000 [ 20%]  (Warmup)\r\nChain 3: Iteration: 2001 / 10000 [ 20%]  (Sampling)\r\nChain 3: Iteration: 3000 / 10000 [ 30%]  (Sampling)\r\nChain 3: Iteration: 4000 / 10000 [ 40%]  (Sampling)\r\nChain 3: Iteration: 5000 / 10000 [ 50%]  (Sampling)\r\nChain 3: Iteration: 6000 / 10000 [ 60%]  (Sampling)\r\nChain 3: Iteration: 7000 / 10000 [ 70%]  (Sampling)\r\nChain 3: Iteration: 8000 / 10000 [ 80%]  (Sampling)\r\nChain 3: Iteration: 9000 / 10000 [ 90%]  (Sampling)\r\nChain 3: Iteration: 10000 / 10000 [100%]  (Sampling)\r\nChain 3: \r\nChain 3:  Elapsed Time: 0.026 seconds (Warm-up)\r\nChain 3:                0.118 seconds (Sampling)\r\nChain 3:                0.144 seconds (Total)\r\nChain 3: \r\n\r\nSAMPLING FOR MODEL 'c6ef9f56b7161f61e60782119367466d' NOW (CHAIN 4).\r\nChain 4: \r\nChain 4: Gradient evaluation took 0 seconds\r\nChain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\r\nChain 4: Adjust your expectations accordingly!\r\nChain 4: \r\nChain 4: \r\nChain 4: Iteration:    1 / 10000 [  0%]  (Warmup)\r\nChain 4: Iteration: 1000 / 10000 [ 10%]  (Warmup)\r\nChain 4: Iteration: 2000 / 10000 [ 20%]  (Warmup)\r\nChain 4: Iteration: 2001 / 10000 [ 20%]  (Sampling)\r\nChain 4: Iteration: 3000 / 10000 [ 30%]  (Sampling)\r\nChain 4: Iteration: 4000 / 10000 [ 40%]  (Sampling)\r\nChain 4: Iteration: 5000 / 10000 [ 50%]  (Sampling)\r\nChain 4: Iteration: 6000 / 10000 [ 60%]  (Sampling)\r\nChain 4: Iteration: 7000 / 10000 [ 70%]  (Sampling)\r\nChain 4: Iteration: 8000 / 10000 [ 80%]  (Sampling)\r\nChain 4: Iteration: 9000 / 10000 [ 90%]  (Sampling)\r\nChain 4: Iteration: 10000 / 10000 [100%]  (Sampling)\r\nChain 4: \r\nChain 4:  Elapsed Time: 0.03 seconds (Warm-up)\r\nChain 4:                0.13 seconds (Sampling)\r\nChain 4:                0.16 seconds (Total)\r\nChain 4: \r\nShow code\r\nposterior <- as.array(fit) ;  plot_title <- ggtitle(\"Posterior distributions\",\r\n                      \"with medians and 80% intervals\")\r\n\r\n\r\n\r\n\r\nShow code\r\nmcmc_areas(posterior, pars =  c(\"lambda\"),prob = 0.8, intervalsprob_outer = 0.99, point_est = \"mean\") + plot_title\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n  summary_poisson<-summary(fit);\r\n  head(summary_poisson$summary)\r\n\r\n\r\n            mean     se_mean        sd      2.5%       25%       50%\r\nlambda  2.508157 0.004255201 0.4597887  1.687862  2.183778  2.478017\r\nlp__   -3.019061 0.006944431 0.7123816 -5.050916 -3.190690 -2.746105\r\n             75%     97.5%    n_eff      Rhat\r\nlambda  2.803256  3.473911 11675.53 0.9999643\r\nlp__   -2.562353 -2.511769 10523.30 0.9999855\r\n\r\n\r\nShow code\r\n  head(posterior)\r\n\r\n\r\n, , parameters = lambda\r\n\r\n          chains\r\niterations  chain:1  chain:2  chain:3  chain:4\r\n      [1,] 2.991037 2.136809 2.747774 2.169443\r\n      [2,] 2.286753 2.183909 2.702732 2.314505\r\n      [3,] 2.581947 2.277992 1.702523 2.006357\r\n      [4,] 2.980970 1.910776 1.897816 1.952687\r\n      [5,] 2.060943 2.683174 1.989799 3.102317\r\n      [6,] 2.554413 2.592420 1.935193 2.587158\r\n\r\n, , parameters = lp__\r\n\r\n          chains\r\niterations   chain:1   chain:2   chain:3   chain:4\r\n      [1,] -3.023839 -2.862300 -2.649554 -2.799202\r\n      [2,] -2.627049 -2.773417 -2.604890 -2.598185\r\n      [3,] -2.527051 -2.637074 -4.466937 -3.186666\r\n      [4,] -3.004177 -3.504029 -3.552678 -3.356054\r\n      [5,] -3.036407 -2.588076 -3.236580 -3.263327\r\n      [6,] -2.518282 -2.531286 -3.416105 -2.529097\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts3/2021-05-29 BDA Project with RStan/2021-05-29-BDA-Project-with-RStan_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2021-12-19T20:11:13+09:00",
    "input_file": {}
  },
  {
    "path": "posts3/2021-03-29 BDA Project with RStan_1/",
    "title": "BDA Project with RStan_1",
    "description": "Introduction",
    "author": [
      {
        "name": "sonsungman",
        "url": "https://sonsungman.github.io/SKKU-Preditive.m/"
      }
    ],
    "date": "2021-03-29",
    "categories": [],
    "contents": "\r\n\r\nShow code\r\nlibrary(tidymodels)\r\nlibrary(tidyverse)\r\nlibrary(magrittr)\r\nlibrary(skimr)\r\nlibrary(knitr)\r\ntheme_set(theme_bw())\r\n\r\n\r\n\r\nUnderstanding Background\r\n베이지안 통계에 대해서 들어보았나? 베이지안 통계의 아이디어는 전통적인 통계학과 다른 관점을 취하고 있다. 빈도주의적(전통적) 통계학의 경우 모수를 MLE를 사용하여 단 하나의 값으로 추정한다. 즉, 모수는 고정된 특정한 값이다. 모집단으로 부터 나온 표본들을 사용하여 우도 함수\\(L(x|\\theta) = \\prod_{i = 1}^{n}f(x_i|\\theta)\\)가 최대가 되게하는 \\(\\theta\\)를 찾는 것이다.\r\n\\[\r\n          \\hat{\\theta} = \\underset{\\theta}{\\operatorname{argmax}}L(x|\\theta)\r\n\\]\r\n반면에 베이지안 통계학은 모수를 하나의 확률변수로 파악한다. 즉, 모수 또한 확률분포를 갖는다. 매커니즘은 간단하다. 베이지안 추론의 요점은 데이터가 주어졌을때에 즉, 관찰치나 표본이라고 할수 있는 값들을 사용해서 우리가 갖는 모수에 관한 사전적 믿음을 업데이트 해나가는 과정이라고 볼 수 있다.\r\nPrior : \\(\\pi(\\theta)\\)\r\nLikehood : \\(f(D|\\theta)\\)\r\nEvidence : \\(f(D) = \\int \\pi(\\theta)f(D|\\theta) d\\theta\\)\r\nPosterior : \\(f(\\theta|D) = \\displaystyle \\frac{\\pi(\\theta)f(D|\\theta)}{f(D)}\\)\r\n데이터를 조건으로하는 모수의 사후분포를 어떻게 추론할 것인가가 베이지안 추론의 요체이다. 위 식에서 우변식 분모 \\(f(D) = \\int \\pi(\\theta)f(D|\\theta) d\\theta\\)을 계산하는 적분은 사전분포와 사후 분포의 공액관계가 있지않다면 계산이 불가능하다. 그렇기에 우리는 일반적으로 사후분포가 우도함수와 사전분포의 곱에 비례한다는 사실\\(f(\\theta|D) \\propto \\pi(\\theta)f(D|\\theta)\\)만 알고 있다. 이 사후분포의 특정을 위해서 저 적분을 풀어 상수 값을 구해서 사후분포를 결정해야하는데 저 적분이 불가능 하니 우리가 알고있는 사실, 사전분포와 우도함수의 곱에 비례함을 바탕으로 사후분포를 수치적으로 근사해야 한다. 이 때에 등장하는 방법이 곧 MCMC이다.\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-12-19T20:11:13+09:00",
    "input_file": {}
  }
]
